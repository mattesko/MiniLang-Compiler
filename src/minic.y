// Code section
%{
// #include "lex.yy.h"
#include <stdio.h>
#include <stdlib.h>

// Reference to the line number generated by the scanner
extern int yylineno;

// The yyerror function is called on any syntax error. When using %define parse.error verbose, this function
// takes a single argument (a string) which contains a detailed explanation of the error.
// Otherwise it takes no arguments and it is up to the user to format the error using a minimal
// description provided in yytext.
void yyerror(const char *s) {
	fprintf(stderr, "Error: (line %d) %s\n", yylineno, s);
	exit(1);
}
void yyerror(const char *s);
%}

%union {
    int int_val;
    char *string_val;
    float float_val;
    unsigned short int bool_val;
    char *identifier;
}

%token VAR FLOAT INT BOOL STRING PRINT WHILE IF ELSE READ
%token GT GTE ST STE COMPARE LOGIC_AND LOGIC_OR NOT_COMPARE

%token <bool_val> BOOL_VAL
%token <string_val> STRING_VAL
%token <int_val> INT_VAL
%token <float_val> FLOAT_VAL
%token <identifier> IDENTIFIER

// Precedence directives
%left LOGIC_OR
%left LOGIC_AND
%left COMPARE NOT_COMPARE
%left GTE STE GT ST
%left '+' '-'
%left '*' '/'
// %nonassoc '{' '}' '(' ')'

%start statements

%locations
%define parse.error verbose

// Grammar rules
%%
statements:
    | statements statement
    | statement
    ;

statement:
    | READ '(' exp ')' 
    | PRINT '(' exp ')'
    | IF '(' exp ')' '{' statement '}'
    | WHILE '(' exp ')' '{' statement '}'
    | decl ';'
    | assign ';'
    ;

decl:
    | VAR IDENTIFIER ':' type_keyword assign
    | VAR assign
    ;

assign:
    | IDENTIFIER '=' exp

exp:  
    | exp '+' exp
    | exp '-' exp
    | exp '*' exp
    | exp '/' exp
    | '(' exp ')'
    | IDENTIFIER
    | BOOL_VAL
    | STRING_VAL
    | INT_VAL
    | FLOAT_VAL
    ;

type_keyword:
    | BOOL
    | STRING
    | INT
    | FLOAT
    ;
%%

// void yyerror(const char* s) {
// 	fprintf(stderr, "Parse error: %s\n", s);
// 	exit(1);
// }
